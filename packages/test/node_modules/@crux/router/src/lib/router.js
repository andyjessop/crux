"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRouter = void 0;
const tslib_1 = require("tslib");
const event_emitter_1 = require("@crux/event-emitter");
const parser_1 = require("./parser");
const trim_slashes_1 = require("./parser/trim-slashes");
const params_to_strings_1 = require("./helpers/params-to-strings");
/**
 * Create a router.
 */
function createRouter(initialRoutes, base = '') {
    const emitter = (0, event_emitter_1.createEventEmitter)();
    const trimmedBase = (0, trim_slashes_1.trimSlashes)(base);
    // Register the initial routes, including the "root" route.
    const encoders = [
        ['root', '/'],
        ['notFound', '/404'],
        ...Object.entries(initialRoutes),
    ].reduce((acc, [name, path]) => {
        const registered = register(name, path);
        if (!registered) {
            return acc;
        }
        // eslint-disable-next-line
        // @ts-ignore
        acc[name] = registered;
        return acc;
    }, {});
    window.addEventListener('popstate', onRouteChange);
    onRouteChange();
    return Object.assign(Object.assign({ back,
        destroy }, emitter), { forward,
        getCurrentRoute,
        go,
        navigate,
        register,
        replace });
    /**
     * Destroy the router.
     */
    function destroy() {
        window.removeEventListener('popstate', onRouteChange);
    }
    /**
     * Create a new route object on a given path.
     */
    function createEncoderBase(path) {
        if (typeof path === 'undefined') {
            return null;
        }
        const fullPath = `${trimmedBase}${path}`;
        return {
            decodeURL: (0, parser_1.parse)(fullPath),
            encodeURL: (0, parser_1.reverse)(fullPath),
        };
    }
    /**
     * Get the current route.
     */
    function getCurrentRoute() {
        const matchingEncoder = getMatchingEncoder(window.location.href);
        if (!matchingEncoder) {
            return null;
        }
        const { name, decodeURL } = matchingEncoder;
        const params = decodeURL(window.location.href);
        if (!params) {
            return null;
        }
        return {
            name,
            params,
        };
    }
    /**
     * Get a route object matching a URL.
     */
    function getMatchingEncoder(url) {
        var _a;
        return ((_a = Object.values(encoders).find((e) => {
            return e.decodeURL(url);
        })) !== null && _a !== void 0 ? _a : encoders.notFound);
    }
    /**
     * Go forwards or backwards by a given number of steps.
     */
    function go(num) {
        window.history.go(num);
    }
    /**
     * Go backwards.
     */
    function back() {
        window.history.go(-1);
    }
    /**
     * Go forwards.
     */
    function forward() {
        window.history.go(1);
    }
    /**
     * Push a new route into the history.
     */
    function navigate(name, params = {}) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const encoder = encoders[name];
            if (!encoder) {
                return transition('notFound');
            }
            return transition(name, params);
        });
    }
    function onRouteChange() {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const matchingEncoder = getMatchingEncoder(window.location.href);
            if (!matchingEncoder) {
                return;
            }
            const { name, decodeURL } = matchingEncoder;
            const params = decodeURL(window.location.href);
            if (!params) {
                return;
            }
            const current = {
                name,
                params,
            };
            yield emitter.emit('routeDidChange', { current, type: 'routeDidChange' });
            emitter.emit('ready', { current, type: 'ready' });
        });
    }
    /**
     * Register a route.
     */
    function register(name, path) {
        if (typeof path === 'undefined' || typeof name === 'undefined') {
            return null;
        }
        const encoderBase = createEncoderBase(path);
        if (!encoderBase) {
            return null;
        }
        return Object.assign(Object.assign({}, encoderBase), { name });
    }
    /**
     * Replace the current location history.
     */
    function replace(name, params = {}) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const encoder = encoders[name];
            if (!encoder) {
                return transition('notFound');
            }
            return transition(encoder.name, params, true);
        });
    }
    /**
     * Transition to a new route.
     */
    function transition(name, params = {}, replace = false) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            let url;
            const current = getCurrentRoute();
            const next = { name, params };
            try {
                const encoder = encoders[name];
                url = encoder.encodeURL((0, params_to_strings_1.paramsToStrings)(params));
            }
            catch (e) {
                emitter.emit('routeChangeFailed', {
                    current,
                    next,
                    type: 'routeChangeFailed',
                });
                return transition('notFound');
            }
            if (!url) {
                emitter.emit('routeChangeFailed', {
                    current,
                    next,
                    type: 'routeChangeFailed',
                });
                return transition('notFound');
            }
            const fullURL = `${window.location.origin}${url}`;
            if (fullURL === window.location.href) {
                return;
            }
            if (replace) {
                window.history.replaceState({ name, params }, '', fullURL);
            }
            else {
                window.history.pushState({ name, params }, '', fullURL);
            }
            onRouteChange();
        });
    }
}
exports.createRouter = createRouter;
//# sourceMappingURL=router.js.map