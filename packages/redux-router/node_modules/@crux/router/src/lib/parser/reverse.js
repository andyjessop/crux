"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reverse = void 0;
const escape_regexes_1 = require("./escape-regexes");
const is_list_1 = require("./is-list");
const is_optional_1 = require("./is-optional");
const param_name_1 = require("./param-name");
const path_to_url_1 = require("./path-to-url");
const reverse_segment_1 = require("./reverse-segment");
const split_path_1 = require("./split-path");
const trim_slashes_1 = require("./trim-slashes");
/**
 * Reverse a pattern, returning an encodeURL function.
 */
function reverse(pattern) {
    const escapedString = (0, escape_regexes_1.escapeRegexes)((0, trim_slashes_1.trimSlashes)(pattern));
    const target = (0, path_to_url_1.pathToURL)(escapedString);
    const segments = (0, split_path_1.splitPath)(target.pathname);
    return function encodeURL(dict) {
        const result = (0, path_to_url_1.pathToURL)('');
        result.pathname = segments.map((x) => (0, reverse_segment_1.reverseSegment)(x, dict)).join('/');
        target.searchParams.forEach((regex, n) => {
            const name = (0, param_name_1.paramName)(n);
            if ((0, is_list_1.isList)(n)) {
                []
                    .concat(dict[name])
                    .filter(Boolean)
                    .forEach((x) => {
                    result.searchParams.append(name, (0, reverse_segment_1.reverseSegment)(x, dict));
                });
            }
            else if (!(0, is_optional_1.isOptional)(n) || dict[name]) {
                result.searchParams.set(name, (0, reverse_segment_1.reverseSegment)(regex, dict));
            }
        });
        result.hash = (0, reverse_segment_1.reverseSegment)(decodeURIComponent(target.hash), dict);
        return `${result}`.replace('ftp://x', '');
    };
}
exports.reverse = reverse;
//# sourceMappingURL=reverse.js.map