import { EventEmitter } from '@crux/event-emitter';
export declare type RouteParams = Record<string, string | null | string[]>;
export interface Route<T> {
    name: T;
    params: RouteParams;
}
export declare type Routes<T> = Record<keyof T, Route<T>>;
export declare type RoutesConfig<T> = Record<keyof T, string>;
export declare type Constructor<T> = (baseRoute: string, config: RoutesConfig<T>) => Router<T>;
export interface EncoderBase {
    decodeURL(url: string): null | RouteParams;
    encodeURL(dict: RouteParams): string;
}
export interface Encoder<N> extends EncoderBase {
    name: N;
}
export interface Router<T> extends EventEmitter<Events<keyof Encoders<T>>> {
    back(): void;
    destroy(): void;
    forward(): void;
    getCurrentRoute(): Route<keyof Encoders<T>> | null;
    go(num: number): void;
    navigate(name: keyof Encoders<T>, params?: RouteParams): Promise<void>;
    register(name: keyof Encoders<T>, path: string): Encoder<keyof Encoders<T>> | null;
    replace(name: keyof Encoders<T>, params?: RouteParams): Promise<void>;
}
declare type Encoders<T> = Record<keyof T, Encoder<keyof T>> & {
    root: Encoder<'root'>;
    notFound: Encoder<'notFound'>;
};
export interface FailedEvent<T, U extends keyof Events<T>> {
    current: Route<T> | null;
    next: Route<T> | null;
    type: U;
}
export interface PopStateEvent<T, U extends keyof Events<T>> {
    current: Route<T> | null;
    type: U;
}
export declare type Events<T> = {
    ready: PopStateEvent<T, 'ready'>;
    routeDidChange: PopStateEvent<T, 'routeDidChange'>;
    routeChangeFailed: FailedEvent<T, 'routeChangeFailed'>;
};
/**
 * Create a router.
 */
export declare function createRouter<T>(initialRoutes: RoutesConfig<T>, base?: string): Router<T>;
export {};
